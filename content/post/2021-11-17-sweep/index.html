---
title: The sweep operator
author: Edoardo Costantini
date: '2021-11-17'
slug: sweep
categories: ["Tutorials", "Drafts"]
tags: ["statistics", "regression"]
subtitle: ''
summary: ''
authors: []
lastmod: '2022-04-02T15:33:01+02:00'
featured: no
image:
  caption: ''
  focal_point: ''
  preview_only: no
projects: []
bibliography: references.bib
output:
  blogdown::html_page:
    toc: true
    toc_depth: 4
    number_sections: true
---

<script src="{{< blogdown/postref >}}index_files/header-attrs/header-attrs.js"></script>

<div id="TOC">
<ul>
<li><a href="#introduction"><span class="toc-section-number">1</span> Introduction</a></li>
<li><a href="#learn-by-coding"><span class="toc-section-number">2</span> Learn by coding</a>
<ul>
<li><a href="#compute-the-augmented-covariance-matrix"><span class="toc-section-number">2.1</span> Compute the augmented covariance matrix</a></li>
<li><a href="#sweep-operator-functions-in-r"><span class="toc-section-number">2.2</span> Sweep operator functions in R</a></li>
<li><a href="#estimate-multivariate-linear-models"><span class="toc-section-number">2.3</span> Estimate multivariate linear models</a></li>
</ul></li>
<li><a href="#tldr-just-give-me-the-code"><span class="toc-section-number">3</span> TL;DR, just give me the code!</a></li>
<li><a href="#references">References</a></li>
</ul>
</div>

<div id="introduction" class="section level1" number="1">
<h1><span class="header-section-number">1</span> Introduction</h1>
<p>The sweep operator is commonly used in linear model computation.
It performs elementary row operations on a <span class="math inline">\(p \times p\)</span> matrix which happen to be particularly useful for the estimation of multivariate linear models.
Little and Rubin <span class="citation">(<a href="#ref-littleRubin:2002" role="doc-biblioref">2002, p148</a>)</span> defined it as follows:</p>
<blockquote>
<p>The sweep operator is defined for symmetric matrices as follows. A <span class="math inline">\(p \times p\)</span> symmetric matrix G is said to be swept on row and column k if it is replaced by another symmetric <span class="math inline">\(p \times p\)</span> matrix H with elements defined as follows:
<span class="math display">\[
h_{kk} = -1/g_{kk}
\]</span>
<span class="math display">\[
h_{jk} = h_{kj} = \frac{g_{jk}}{g_{kk}}, j \neq k
\]</span>
<span class="math display">\[
h_{jl} = g_{jl} - \frac{g_{jk}g_{kl}}{g_{kk}}, j \neq k, l \neq k
\]</span></p>
</blockquote>
<p>In this post, I’m interested in exploring how we use the sweep operator in the estimation of the parameters of linear models.
What is important to note is that when we want to sweep a symmetric matrix G over the row and column k we are simply replacing the elements of G with the results of these three equations.
If you are interested in the details of these equations, I recommend reading the full sweep operator description in Schafer Little and the Original paper.</p>
</div>
<div id="learn-by-coding" class="section level1" number="2">
<h1><span class="header-section-number">2</span> Learn by coding</h1>
<p>To understand the sweep operator we will use it to compute the regression coefficient of a multivariate linear model estimated on an example dataset.
For this post, we will work with the data used by Little and Rubin <span class="citation">(<a href="#ref-littleRubin:2002" role="doc-biblioref">2002, p152</a>)</span>.</p>
<pre class="r"><code># Load Little Rubin data -------------------------------------------------------

# Create data
  X &lt;- as.data.frame(
          matrix(
                  data = c(7, 1, 11, 11, 7, 11, 3, 1, 2, 21, 1, 11, 10, 26,
                           29, 56, 31, 52, 55, 71 ,31, 54, 47, 40, 66, 68,
                           6, 15, 8, 8, 6, 9, 17, 22, 18, 4, 23, 9, 8,
                           60, 52, 20, 47, 33, 22,6,44,22,26,34,12,12,
                           78.5, 74.3, 104.3, 87.6, 95.9, 109.2, 102.7,
                           72.5, 93.1, 115.9, 83.8, 113.3, 109.4),
                  ncol = 5
          )
  )

# Store useful information
  n &lt;- nrow(X)
  p &lt;- ncol(X)</code></pre>
<p>Let’s take a quick look at the first rows of the data to get an idea of what we are working with.</p>
<pre class="r"><code># Glace at the first 6 rows of the data
  head(X)</code></pre>
<pre><code>##   V1 V2 V3 V4    V5
## 1  7 26  6 60  78.5
## 2  1 29 15 52  74.3
## 3 11 56  8 20 104.3
## 4 11 31  8 47  87.6
## 5  7 52  6 33  95.9
## 6 11 55  9 22 109.2</code></pre>
<div id="compute-the-augmented-covariance-matrix" class="section level2" number="2.1">
<h2><span class="header-section-number">2.1</span> Compute the augmented covariance matrix</h2>
<p>The sweep operator gets us the regression coefficients of a multivairate linear model when applied to what is known as the augmented covariance matrix of the data <span class="math inline">\(\Theta\)</span>.
This is a <span class="math inline">\((p+1) \times (p+1)\)</span> matrix storing the covariance matrix and the means of the dataset.</p>
<p><span class="math display">\[
\Theta =
\begin{bmatrix}
-1 &amp; \mu_1 &amp; ... &amp;\mu_p\\
\mu_1 &amp; \sigma^2_1 &amp; ... &amp; \sigma_{1p}\\
... &amp; ... &amp; ... &amp; ...\\
\mu_p &amp; \sigma_{1p} &amp; ... &amp; \sigma^2_{pp}
\end{bmatrix}
\]</span></p>
<p>Starting from our dataset, we can obtain this matrix in just a few steps:</p>
<ul>
<li><p><strong>Augment the original data</strong> with a column of 1s on the left</p>
<pre class="r"><code># Obtain the augmented covariance matrix ---------------------------------------

# Augment X
  X_aug &lt;- cbind(int = 1, as.matrix(X))</code></pre>
<p>Check out how <code>X_aug</code> looks.</p>
<pre class="r"><code># Glance at the first 6 rows of X_aug
  head(X_aug)</code></pre>
<pre><code>##      int V1 V2 V3 V4    V5
## [1,]   1  7 26  6 60  78.5
## [2,]   1  1 29 15 52  74.3
## [3,]   1 11 56  8 20 104.3
## [4,]   1 11 31  8 47  87.6
## [5,]   1  7 52  6 33  95.9
## [6,]   1 11 55  9 22 109.2</code></pre></li>
<li><p>Compute the <strong>augmented matrix of sufficient statistics <span class="math inline">\(T\)</span></strong>.</p>
<p><span class="math inline">\(T\)</span> is the matrix having as elements the sum of the cross-products of the columns of <code>X_aug</code>.
Since the first column of <code>X_aug</code> is a column of 1s, the first element of T is the number of rows in the data, the first column and rows store the sum of scores on each variable (sufficient statistics for the mean), and the other elements store the sum of products between the columns of <code>X</code> (sufficeint statistics for the covariance matrix of <code>X</code>).</p>
<p><span class="math display">\[
T =
\begin{bmatrix}
n &amp; \sum{x_1} &amp; ... &amp; \sum{x_p}\\
\sum{x_1} &amp; \sum{x_1^2} &amp; ... &amp; \sum{x_1 x_p}\\
... &amp; ... &amp; ... &amp; ...\\
\sum{x_p} &amp; \sum{x_1 x_p} &amp; ... &amp; \sum{x_p^2}
\end{bmatrix}
\]</span>
In R, we can compute it easily with the cross-product function</p>
<pre class="r"><code># Compute the matrix of sufficient statistics (T matrix)
  Tmat &lt;- crossprod(X_aug)</code></pre></li>
</ul>
<p>We will use the sweep operator to compute the regression coefficients of different multivairate linear models.</p>
</div>
<div id="sweep-operator-functions-in-r" class="section level2" number="2.2">
<h2><span class="header-section-number">2.2</span> Sweep operator functions in R</h2>
<p>I can use mine and I can show other people’s functions.</p>
</div>
<div id="estimate-multivariate-linear-models" class="section level2" number="2.3">
<h2><span class="header-section-number">2.3</span> Estimate multivariate linear models</h2>
<p>First, let’s compute this matrix based on the data we have at hand.
First, let’s see how we would obtain these linear moldes in R with standard procedures.
Let’s start by fitting an intercept only multivariate linear model.
Let’s regress <code>V5</code> and <code>V4</code> on a vector of <code>1s</code>.</p>
<pre class="r"><code># Fit some multivariate linear models ------------------------------------------

# Multivariate intercept only model
  # Define the dvs
  dvs &lt;- c(&quot;V5&quot;, &quot;V4&quot;)

  # Complicated but flexible way of writing the formula
  formula_lm &lt;- paste0(&quot;cbind(&quot;,
                       paste0(dvs, collapse = &quot;, &quot;),
                       &quot;) ~ 1&quot;)

  # Fit the model with the MLM
  mlm0 &lt;- lm(formula_lm, data = X)

  # Do it with sweep shortcut
  coef(mlm0)</code></pre>
<pre><code>##                   V5 V4
## (Intercept) 95.42308 30</code></pre>
<pre class="r"><code>  # sweepGoodnight(T0, 1)[&quot;int&quot;, dvs]
  # sweepGoodnight(G, 1)[&quot;int&quot;, dvs]
  # theta[&quot;int&quot;, dvs]</code></pre>
</div>
</div>
<div id="tldr-just-give-me-the-code" class="section level1" number="3">
<h1><span class="header-section-number">3</span> TL;DR, just give me the code!</h1>
<pre class="r"><code># Packages and functions
source(&quot;sweepGoodnight.R&quot;) # main sweep function
library(ISR3)                  # for SWP functions
library(fastmatrix)            # alternative sweep

# Take the mtcars data
y &lt;- mtcars[, &quot;mpg&quot;]
X &lt;- mtcars[, -1]

# Create a few shorthands we will use
n &lt;- nrow(X)
p &lt;- ncol(X)

# Load Little Rubin data -------------------------------------------------------

# Create data
  X &lt;- as.data.frame(
          matrix(
                  data = c(7, 1, 11, 11, 7, 11, 3, 1, 2, 21, 1, 11, 10, 26,
                           29, 56, 31, 52, 55, 71 ,31, 54, 47, 40, 66, 68,
                           6, 15, 8, 8, 6, 9, 17, 22, 18, 4, 23, 9, 8,
                           60, 52, 20, 47, 33, 22,6,44,22,26,34,12,12,
                           78.5, 74.3, 104.3, 87.6, 95.9, 109.2, 102.7,
                           72.5, 93.1, 115.9, 83.8, 113.3, 109.4),
                  ncol = 5
          )
  )

# Store useful information
  n &lt;- nrow(X)
  p &lt;- ncol(X)
# Glace at the first 6 rows of the data
  head(X)
# Obtain the augmented covariance matrix ---------------------------------------

# Augment X
  X_aug &lt;- cbind(int = 1, as.matrix(X))

# Glance at the first 6 rows of X_aug
  head(X_aug)

# Compute the matrix of sufficient statistics (T matrix)
  Tmat &lt;- crossprod(X_aug)

# Fit some multivariate linear models ------------------------------------------

# Multivariate intercept only model
  # Define the dvs
  dvs &lt;- c(&quot;V5&quot;, &quot;V4&quot;)

  # Complicated but flexible way of writing the formula
  formula_lm &lt;- paste0(&quot;cbind(&quot;,
                       paste0(dvs, collapse = &quot;, &quot;),
                       &quot;) ~ 1&quot;)

  # Fit the model with the MLM
  mlm0 &lt;- lm(formula_lm, data = X)

  # Do it with sweep shortcut
  coef(mlm0)
  # sweepGoodnight(T0, 1)[&quot;int&quot;, dvs]
  # sweepGoodnight(G, 1)[&quot;int&quot;, dvs]
  # theta[&quot;int&quot;, dvs]</code></pre>
</div>
<div id="references" class="section level1 unnumbered">
<h1>References</h1>
<div id="refs" class="references csl-bib-body hanging-indent">
<div id="ref-littleRubin:2002" class="csl-entry">
Little, R. J. A., and D. B. Rubin. 2002. <em>Statistical Analysis with Missing Data</em>. 2nd ed. Hoboken, NJ: Wiley-Interscience.
</div>
</div>
</div>
